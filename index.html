<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>יומן חפ"ק - לפיד</title>
    <!-- Firebase CDN -->
    <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Assistant:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Chosen Palette: Warm Neutrals -->
    <!-- Application Structure Plan: A single-page, task-oriented application designed for efficient data entry and management, now with data persistence via Firestore. The primary input area features report description, reporter, log type, and action buttons arranged horizontally on larger screens for compact and efficient interaction. Date and time inputs are hidden by default and only appear when editing an existing report. When visible for editing, the date input uses a native picker, and the time input allows direct manual typing. On smaller screens, these elements gracefully stack vertically to maintain usability. This consolidated input block is followed by the main content area displaying the data table. The table now features date-based grouping with expand/collapse functionality (default collapsed for non-today dates) and global expand/collapse controls. Sorting has a hybrid behavior: new additions always go to top (LIFO), while updates trigger a full chronological sort (date descending, then time descending) for the entire table. -->
    <!-- Visualization & Content Choices: Report Data -> Goal: Input/Manage/Persist -> Presentation: Consolidated HTML Form (for add/edit) & Grouped Collapsible HTML Table -> Interaction: Users input data via form. Add button is LIFO (visual). Update button triggers full chronological sort. Edit button reveals date/time inputs for modification. Date input is type="date". Time input is type="text" with manual input. Global/per-day buttons control collapse state. Textarea auto-resizes in add mode, fixed height in edit. Data is persisted to Firestore. Justification: Enhanced usability for data entry and review, clear visual organization, precise adherence to complex sorting requirements, and critical data persistence. Library/Method: Vanilla JS for DOM manipulation and state management, Tailwind CSS for styling and responsiveness, Firebase Firestore for data persistence, Firebase Auth for user management. -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        body {
            font-family: 'Assistant', sans-serif;
            background-color: #FDFBF7;
        }
        .table-cell {
            padding: 12px 16px;
            text-align: right;
            border-bottom: 1px solid #EAE2D9;
            vertical-align: middle;
        }
        /* Remove default border from inner table cells for cleaner look */
        .collapsible-content table .table-cell {
            border-bottom: none;
        }
        .collapsible-content table tbody tr:last-child .table-cell {
            border-bottom: 1px solid #EAE2D9; /* Add border to last row of inner table */
        }

        .form-input, .form-select, .form-textarea {
            border-color: #DCD5CC;
            transition: all 0.3s ease;
        }
        .form-input:focus, .form-select:focus, .form-textarea:focus {
            border-color: #B8A692;
            box-shadow: 0 0 0 2px rgba(184, 166, 146, 0.2);
            outline: none;
        }
        .btn-primary {
            background-color: #8C7A6B;
            color: #FFFFFF;
            transition: background-color 0.3s ease;
        }
        .btn-primary:hover {
            background-color: #736357;
        }
        .btn-secondary {
            background-color: #EAE2D9;
            color: #6D5F53;
            transition: background-color 0.3s ease;
        }
        .btn-secondary:hover {
            background-color: #DCD5CC;
        }
        /* Fixed height for textarea in edit mode */
        .form-textarea.edit-mode-fixed-height {
            height: auto !important; /* Override auto-sizing */
            min-height: calc(1.5em * 5 + 1rem); /* 5 lines height roughly (line-height * rows + padding) */
            resize: vertical; /* Allow manual resize if desired */
        }
    </style>
</head>
<body class="bg-[#FDFBF7] text-[#4A443E]">

    <div class="container mx-auto p-4 sm:p-6 md:p-8 max-w-5xl">

        <header class="text-center mb-6">
            <h1 class="text-3xl md:text-4xl font-bold text-[#6D5F53]">יומן חפ"ק - לפיד</h1>
            <p id="userIdDisplay" class="text-sm text-[#8C7A6B] mt-2"></p> <!-- User ID display -->
        </header>

        <main class="bg-white rounded-xl shadow-lg p-6 ring-1 ring-[#EAE2D9]">
            <div class="controls-section mb-6 pb-6 border-b border-[#EAE2D9]">
                
                <div class="max-w-full mx-auto mb-6 p-4 bg-[#F8F5F1] rounded-lg shadow-inner">
                    <div class="flex flex-col sm:flex-row items-end gap-4">
                        <div class="flex-grow-[5] w-full sm:w-auto min-w-0"> <!-- Increased flex-grow for wider textarea -->
                            <label for="generalTextInput" class="block mb-1 text-sm font-semibold text-[#6D5F53]">תיאור דיווח:</label>
                            <textarea id="generalTextInput" class="form-textarea w-full p-2 border rounded-md" rows="3" placeholder="פרטי דיווח קצרים..."></textarea>
                        </div>
                        
                        <div class="flex-shrink-0 w-full sm:w-auto"> <label for="filterReporter" class="block mb-1 text-sm font-semibold text-[#8C7A6B]">מדווח:</label>
                            <select id="filterReporter" class="form-select w-full p-2.5 bg-white border rounded-lg shadow-sm">
                                <option value="אורי">אורי</option>
                                <option value="שונית">שונית</option>
                                <option value="חיליק">חיליק</option>
                            </select>
                        </div>
                        
                        <div class="flex-shrink-0 w-full sm:w-auto"> <label for="filterLogType" class="block mb-1 text-sm font-semibold text-[#8C7A6B]">שיוך:</label>
                            <select id="filterLogType" class="form-select w-full p-2.5 bg-white border rounded-lg shadow-sm">
                                <option value="שגרה">שגרה</option>
                                <option value="שריפה">שריפה</option>
                                <option value="אחר">אחר</option>
                            </select>
                        </div>
                        
                        <!-- New container for date/time, hidden by default and stacked -->
                        <div id="dateTimeInputsWrapper" class="flex-shrink-0 w-full sm:w-48 hidden">
                            <div class="flex flex-col gap-2"> <!-- Stack date and time vertically -->
                                <div>
                                    <label for="newDate" class="block mb-1 text-sm font-semibold text-[#6D5F53]">תאריך:</label>
                                    <input type="date" id="newDate" class="form-input w-full p-2 border rounded-md">
                                </div>
                                <div>
                                    <label for="newTime" class="block mb-1 text-sm font-semibold text-[#6D5F53]">שעה:</label>
                                    <input type="text" id="newTime" class="form-input w-full p-2 border rounded-md" placeholder="HH:MM" pattern="([01]?[0-9]|2[0-3]):[0-5][0-9]">
                                </div>
                            </div>
                        </div>

                        <div class="flex-shrink-0 w-full sm:w-auto flex flex-row sm:flex-col items-end gap-2"> <button id="mainActionBtn" class="btn-primary font-bold py-2 px-6 rounded-lg shadow w-full sm:w-auto">הזן</button>
                            <button id="cancelEditBtn" class="btn-secondary font-bold py-2 px-6 rounded-lg shadow w-full sm:w-auto hidden">ביטול</button>
                        </div>
                    </div>
                    <div id="inputErrorMessage" class="text-red-500 text-center mt-4 h-5"></div>
                </div>

            </div>

            <div class="table-container overflow-x-auto">
                <div class="flex justify-start gap-4 mb-4"> <!-- Global buttons for table control -->
                    <button id="expandAllBtn" class="btn-secondary font-bold py-1.5 px-4 rounded-lg shadow text-sm">פתח הכל</button>
                    <button id="collapseAllBtn" class="btn-secondary font-bold py-1.5 px-4 rounded-lg shadow text-sm">צמצם הכל</button>
                </div>
                
                <table class="w-full min-w-full text-sm">
                    <thead>
                        <tr>
                            <th class="table-cell font-bold text-[#6D5F53]">דיווח</th>
                            <th class="table-cell font-bold text-[#6D5F53]">תאריך</th>
                            <th class="table-cell font-bold text-[#6D5F53]">שעה</th>
                            <th class="table-cell font-bold text-[#6D5F53]">שם המדווח</th>
                            <th class="table-cell font-bold text-[#6D5F53]">שיוך יומן</th>
                            <th class="table-cell font-bold text-[#6D5F53]">פעולות</th>
                        </tr>
                    </thead>
                    <tbody id="reportTableBody">
                        <tr id="empty-state">
                            <td colspan="6" class="table-cell text-center text-gray-500 py-8">לא נוספו דיווחים עדיין.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </main>

    </div>

    <script type="module">
        // Firebase global variables
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, setDoc, onSnapshot, query, orderBy, doc, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global variables for Firebase and App State
        let db;
        let auth;
        let userId;
        let reportsCollectionRef;
        let isAuthReady = false; 

        let reports = []; 
        let editingReportIndex = null; 
        let lastAddedReportId = null; 
        let collapsedGroups = new Set(); 

        // Global DOM element references (initialized in DOMContentLoaded)
        let filterReporter;
        let filterLogType;
        let generalTextInput;
        let newDateInput; 
        let newTimeInput; 
        let dateTimeInputsWrapper; 
        let mainActionBtn;
        let cancelEditBtn;
        let tableBody;
        let emptyStateRow;
        let inputErrorMessage;
        let expandAllBtn;
        let collapseAllBtn;


        // Initialize Firebase and set up listener
        const initializeFirebaseAndListeners = async () => {
            try {
                const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                // Authenticate and set up listener
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        document.getElementById('userIdDisplay').textContent = `מזהה משתמש: ${userId}`;
                        reportsCollectionRef = collection(db, `artifacts/${appId}/users/${userId}/reports`);
                        isAuthReady = true;

                        // Set up real-time listener for reports
                        // Use orderBy('timestamp', 'desc') to get initial data sorted by insertion/update time
                        onSnapshot(query(reportsCollectionRef, orderBy('timestamp', 'desc')), (snapshot) => {
                            reports = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                            reports = reports.filter(report => report.timestamp); 
                            renderTable(); // Re-render table whenever data changes in Firestore
                        });
                    } else {
                        // Sign in anonymously if no user is authenticated
                        if (typeof __initial_auth_token !== 'undefined') {
                            try {
                                await signInWithCustomToken(auth, __initial_auth_token);
                            } catch (error) {
                                console.error("Error signing in with custom token:", error);
                                await signInAnonymously(auth); // Fallback to anonymous if custom token fails
                            }
                        } else {
                            await signInAnonymously(auth);
                        }
                    }
                });

            } catch (error) {
                console.error("Error initializing Firebase or signing in:", error);
                // Using console.error instead of alert to avoid blocking UI in an iframe
                console.error("שגיאה באתחול האפליקציה: " + error.message);
            }
        };

        // --- Auto-resize Textarea Logic ---
        const autoResizeTextarea = (textarea) => {
            textarea.style.height = 'auto'; 
            textarea.style.height = (textarea.scrollHeight) + 'px'; 
        };

        // Sets default date and time in the input fields (used for initial load and after reset)
        const setDefaultDateTime = () => {
            const now = new Date();
            const year = now.getFullYear();
            const month = (now.getMonth() + 1).toString().padStart(2, '0');
            const day = now.getDate().toString().padStart(2, '0');
            newDateInput.value = `${year}-${month}-${day}`;
            
            const hours = now.getHours().toString().padStart(2, '0');
            const minutes = now.getMinutes().toString().padStart(2, '0');
            newTimeInput.value = `${hours}:${minutes}`; 
        };
        
        // Function to validate time format (HH:MM)
        const isValidTimeFormat = (timeString) => {
            const pattern = /^([01]?[0-9]|2[0-3]):[0-5][0-9]$/;
            return pattern.test(timeString);
        };

        // Function to format date as DD/MM/YYYY
        const formatAsDDMMYYYY = (dateString) => {
            const date = new Date(dateString);
            const day = date.getDate().toString().padStart(2, '0');
            const month = (date.getMonth() + 1).toString().padStart(2, '0');
            const year = date.getFullYear();
            return `${day}/${month}/${year}`;
        };

        // Function to sort reports by date (descending) then time (descending) - operates on an array COPY
        const sortChronologically = (arrToSort) => { 
            return [...arrToSort].sort((a, b) => { 
                const dateA = new Date(a.date);
                const dateB = new Date(b.date);

                if (dateA > dateB) return -1; 
                if (dateA < dateB) return 1;  

                if (a.time > b.time) return -1; 
                if (a.time < b.time) return 1;  

                return 0; 
            });
        };

        // Renders the table content based on the reports array and current sorting rules
        const renderTable = () => {
            tableBody.innerHTML = ''; // Clear existing table body
            
            if (reports.length === 0) {
                tableBody.appendChild(emptyStateRow);
                console.log('No reports to display.');
                return;
            }

            let finalDisplayList = [...reports]; 

            // Apply hybrid sorting logic:
            // Rule 1: The last NEWLY ADDED report always at the top.
            if (lastAddedReportId) {
                const lastAddedIndex = finalDisplayList.findIndex(report => report.id === lastAddedReportId);
                if (lastAddedIndex !== -1) {
                    const [topReport] = finalDisplayList.splice(lastAddedIndex, 1); 
                    finalDisplayList.unshift(topReport); 
                } else {
                    lastAddedReportId = null; 
                }
            }
            
            // Group reports by date for rendering
            const groupedReports = new Map();
            finalDisplayList.forEach(report => {
                const dateKey = report.date; 
                if (!groupedReports.has(dateKey)) {
                    groupedReports.set(dateKey, []);
                }
                groupedReports.get(dateKey).push(report);
            });

            // Sort the date keys for displaying date groups chronologically (descending)
            const sortedDateKeys = Array.from(groupedReports.keys()).sort((a, b) => {
                return new Date(b) - new Date(a);
            });

            const today = new Date();
            const todayKey = `${today.getFullYear()}-${(today.getMonth() + 1).toString().padStart(2, '0')}-${today.getDate().toString().padStart(2, '0')}`;

            sortedDateKeys.forEach(dateKey => {
                const reportsForDate = groupedReports.get(dateKey);
                const isToday = dateKey === todayKey;
                const isCollapsed = collapsedGroups.has(dateKey); 

                // Date Header Row
                const headerRow = document.createElement('tr');
                headerRow.className = 'date-group-header bg-[#F8F5F1] border-b-2 border-[#DCD5CC]';
                headerRow.innerHTML = `
                    <td colspan="6" class="p-3 font-bold text-[#6D5F53] text-right">
                        <button class="toggle-day-btn text-blue-600 hover:text-blue-800 ml-2" data-toggle-date="${dateKey}">
                            ${isCollapsed ? '◀' : '▼'}
                        </button>
                        ${formatAsDDMMYYYY(dateKey)}
                    </td>
                `;
                tableBody.appendChild(headerRow);

                // Content Rows Wrapper (collapsible)
                const reportsContainerRow = document.createElement('tr');
                reportsContainerRow.className = `date-group-content ${isCollapsed ? 'hidden' : ''}`; 
                reportsContainerRow.dataset.contentDate = dateKey; 

                const reportsCell = document.createElement('td');
                reportsCell.colSpan = 6;
                reportsCell.className = 'p-0'; 

                const innerTable = document.createElement('table'); 
                innerTable.className = 'w-full text-sm';
                const innerTbody = document.createElement('tbody');

                // Render individual report rows inside the inner table
                reportsForDate.forEach(report => {
                    const reportRow = document.createElement('tr');
                    reportRow.className = 'hover:bg-[#F8F5F1]';
                    reportRow.innerHTML = `
                        <td class="table-cell">${report.description.replace(/\n/g, '<br>')}</td>
                        <td class="table-cell">${formatAsDDMMYYYY(report.date)}</td>
                        <td class="table-cell">${report.time}</td>
                        <td class="table-cell">${report.reporter}</td>
                        <td class="table-cell">${report.logType}</td>
                        <td class="table-cell text-center whitespace-nowrap">
                            <button data-id="${report.id}" class="text-blue-600 hover:text-blue-800 font-semibold edit-btn">ערוך</button>
                        </td>
                    `;
                    innerTbody.appendChild(reportRow);
                });

                innerTable.appendChild(innerTbody);
                reportsCell.appendChild(innerTable);
                reportsContainerRow.appendChild(reportsCell);
                tableBody.appendChild(reportsContainerRow);
                
                // Default collapse/expand logic for initial rendering
                if (!isToday && !collapsedGroups.has(dateKey)) {
                    collapsedGroups.add(dateKey);
                    reportsContainerRow.classList.add('hidden');
                    headerRow.querySelector('.toggle-day-btn').textContent = '◀';
                }
            });

            // Attach event listeners for individual toggle buttons (delegation from tableBody would be more efficient)
            tableBody.querySelectorAll('.toggle-day-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    const dateToToggle = e.target.dataset.toggleDate;
                    const contentRow = tableBody.querySelector(`tr[data-content-date="${dateToToggle}"]`);
                    if (contentRow) {
                        contentRow.classList.toggle('hidden');
                        if (contentRow.classList.contains('hidden')) {
                            e.target.textContent = '◀';
                            collapsedGroups.add(dateToToggle);
                        } else {
                            e.target.textContent = '▼';
                            collapsedGroups.delete(dateToToggle);
                        }
                    }
                });
            });
            
            console.log('Current reports array (raw data from Firestore):', reports); 
            console.log('Reports displayed in table (after hybrid sorting and grouping):', finalDisplayList);
            console.log('Collapsed Groups State:', collapsedGroups);
        };

        // Clears the input fields and resets the form to "add new report" mode
        const resetForm = () => {
            generalTextInput.value = '';
            generalTextInput.rows = 3; 
            generalTextInput.style.height = 'auto'; 
            generalTextInput.classList.remove('edit-mode-fixed-height'); 
            autoResizeTextarea(generalTextInput); 

            setDefaultDateTime(); 
            generalTextInput.focus();
            editingReportIndex = null; 
            mainActionBtn.textContent = 'הזן';
            cancelEditBtn.classList.add('hidden');
            inputErrorMessage.textContent = '';
            
            dateTimeInputsWrapper.classList.add('hidden'); 

            newDateInput.readOnly = false; 
            newTimeInput.readOnly = false; 

            renderTable(); 
        };

        // Adds a new report
        const addReport = async () => { 
            const description = generalTextInput.value.trim();
            const date = newDateInput.value; 
            const time = newTimeInput.value; 
            
            const reporter = filterReporter.value; 
            const logType = filterLogType.value;   

            if (!description) { 
                inputErrorMessage.textContent = 'יש למלא את שדה תיאור הדיווח.';
                setTimeout(() => inputErrorMessage.textContent = '', 3000);
                return;
            }

            if (!isAuthReady) {
                inputErrorMessage.textContent = 'האפליקציה עדיין מתחברת, אנא המתן ונסה שוב.';
                setTimeout(() => inputErrorMessage.textContent = '', 3000);
                return;
            }

            const newReportData = { 
                description, 
                date, 
                time, 
                reporter, 
                logType,
                timestamp: serverTimestamp() 
            };

            try {
                const docRef = await addDoc(reportsCollectionRef, newReportData);
                // The onSnapshot listener will update 'reports' array and call renderTable.
                // We just need to track the ID of the new report for LIFO display
                lastAddedReportId = docRef.id; 
                collapsedGroups.delete(newReportData.date); // Open the group for the newly added report
                resetForm(); 
            } catch (e) {
                console.error("Error adding document: ", e);
                inputErrorMessage.textContent = 'שגיאה בהוספת הדיווח: ' + e.message;
                setTimeout(() => inputErrorMessage.textContent = '', 5000);
            }
        };

        // Updates an existing report
        const updateReport = async () => { 
            const description = generalTextInput.value.trim();
            const date = newDateInput.value; 
            const time = newTimeInput.value; 

            const reporter = filterReporter.value; 
            const logType = filterLogType.value;   

            if (!description || !date || !time) { 
                inputErrorMessage.textContent = 'יש למלא את כל השדות: תיאור, תאריך ושעה.';
                setTimeout(() => inputErrorMessage.textContent = '', 3000);
                return;
            }
            if (!isValidTimeFormat(time)) { 
                inputErrorMessage.textContent = 'פורמט שעה שגוי. אנא הזן HH:MM (לדוגמה, 14:30).';
                setTimeout(() => inputErrorMessage.textContent = '', 3000);
                return;
            }

            if (!isAuthReady || editingReportIndex === null) {
                 inputErrorMessage.textContent = 'האפליקציה עדיין מתחברת או שאין דיווח לעדכן.';
                 setTimeout(() => inputErrorMessage.textContent = '', 3000);
                 return;
            }

            const reportToUpdateInFirestore = reports[editingReportIndex];
            const docId = reportToUpdateInFirestore.id; 

            const updatedData = {
                description,
                date,
                time,
                reporter,
                logType,
                timestamp: serverTimestamp() 
            };

            try {
                await setDoc(doc(db, reportsCollectionRef.path, docId), updatedData);
                // Firestore onSnapshot will fetch the updated list and trigger renderTable.
                // It's crucial here to re-sort the 'reports' array based on the new data
                // and then clear lastAddedReportId as this is an update, not a new add.
                reports = sortChronologically(reports); // Sort the global reports array directly
                lastAddedReportId = null; // Clear last added to ensure full chronological sort is dominant now
                
                collapsedGroups.delete(updatedData.date); // Open the group for the updated report

                resetForm(); 
            } catch (e) {
                console.error("Error updating document: ", e);
                inputErrorMessage.textContent = 'שגיאה בעדכון הדיווח: ' + e.message;
                setTimeout(() => inputErrorMessage.textContent = '', 5000);
            }
        };

        // Handles the click on the main action button (Add/Update)
        mainActionBtn.addEventListener('click', () => {
            if (editingReportIndex === null) {
                addReport();
            } else {
                updateReport();
            }
        });

        // Handles the click on the cancel edit button
        cancelEditBtn.addEventListener('click', resetForm);
        
        // Event delegation for table actions (edit)
        tableBody.addEventListener('click', (e) => {
            // Edit button
            if (e.target.classList.contains('edit-btn')) {
                const reportIdToEdit = e.target.getAttribute('data-id');
                const index = reports.findIndex(report => report.id === reportIdToEdit);
                
                if (index === -1) {
                    console.error('Report not found for editing:', reportIdToEdit);
                    return;
                }

                const reportToEdit = reports[index];
                
                // Populate inputs with report data
                generalTextInput.value = reportToEdit.description;
                newDateInput.value = reportToEdit.date;
                newTimeInput.value = reportToEdit.time; 
                filterReporter.value = reportToEdit.reporter; 
                filterLogType.value = reportToEdit.logType;   
                
                editingReportIndex = index; 
                mainActionBtn.textContent = 'עדכן דיווח'; 
                cancelEditBtn.classList.remove('hidden'); 
                
                // SHOW date and time inputs when editing
                dateTimeInputsWrapper.classList.remove('hidden'); 

                // Set textarea to fixed height for edit mode
                generalTextInput.rows = 5; 
                generalTextInput.style.height = 'auto'; 
                generalTextInput.classList.add('edit-mode-fixed-height'); 

                // Date input should allow picker, not manual typing (type="date")
                newDateInput.readOnly = false; 

                // Time input should allow direct manual input (type="text")
                newTimeInput.readOnly = false; 

                generalTextInput.focus(); 
            }
        });

        // DOMContentLoaded listener
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize global DOM element references
            filterReporter = document.getElementById('filterReporter');
            filterLogType = document.getElementById('filterLogType');
            generalTextInput = document.getElementById('generalTextInput');
            newDateInput = document.getElementById('newDate'); 
            newTimeInput = document.getElementById('newTime'); 
            dateTimeInputsWrapper = document.getElementById('dateTimeInputsWrapper'); 
            mainActionBtn = document.getElementById('mainActionBtn');
            cancelEditBtn = document.getElementById('cancelEditBtn');
            tableBody = document.getElementById('reportTableBody');
            emptyStateRow = document.getElementById('empty-state');
            inputErrorMessage = document.getElementById('inputErrorMessage');
            expandAllBtn = document.getElementById('expandAllBtn');
            collapseAllBtn = document.getElementById('collapseAllBtn');

            // Initialize default date and time, and render table on load
            setDefaultDateTime();
            resetForm(); 
            initializeFirebaseAndListeners(); // Initialize Firebase and start listening
        });
    </script>
</body>
</html>
